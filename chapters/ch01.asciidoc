### DRAFT

[[module-thinking]]
== Модульное мышление

Как обсуждалось в предисловии, сложность, кажется, вокруг нас, пока мы работаем над программными проектами. Таким образом, абстракции, которые сдерживают сложность, скрытую от нас под камнями, мы не смеем трогать. Эти камни являются нашими интерфейсами для остального мира, так что мы можем уйти, едва думая об этом. JavaScript здесь не исключение - наоборот: такие же мощные, как и динамические языки, гораздо проще и даже соблазнительно писать сложные программы, когда мы их используем.

Чтобы начать работу, давайте обсудим, как мы можем лучше применять абстракции, интерфейсы и их базовые концепции к работе, которую мы делаем, чтобы мы могли минимизировать сложность, с которой мы должны смотреть, когда работаем над проектом, функцией, частью функциональности, вплоть до ветвей одной функции.

=== 1.1 Введение в модульное мышление

Охватывая модульное мышление, понимает, что сложность, в конечном счете, неизбежна. В то же время эта сложность может быть охвачена интерфейсом, который вряд ли когда-либо будет замечен или задуман. Но, и вот одна из сложных функций, интерфейс должен быть хорошо разработан, чтобы его пользователи не расстраивались. Это разочарование может даже заставить нас заглянуть под капот и обнаружить, что реализация намного сложнее, чем плохой интерфейс, с которым мы расстраиваемся, и, возможно, если интерфейс не существует в первую очередь, нам будет лучше с точки зрения ремонтопригодности и удобочитаемости.

Системы могут быть организованы гранулярно: мы можем разделить их на проекты, состоящие из нескольких приложений, содержащих несколько уровней уровня приложения, где мы можем иметь сотни модулей, состоящих из тысяч функций и т. Д. Гранулярный подход помогает нам писать код, который легко понять и поддерживать, достигая разумной степени модульности, сохраняя при этом наше здравомыслие. В разделе 1.4 мы обсудим, как мы можем лучше использовать эту гранулярность для создания модульных приложений.

Всякий раз, когда мы определяем компонент, будет публичный интерфейс, который другие части системы могут использовать для доступа к нашему компоненту. Интерфейс - или API - состоит из набора методов или атрибутов, предоставляемых нашим компонентом. Эти методы или атрибуты также могут упоминаться как сенсорные точки, то есть аспекты интерфейса, с которыми можно публично взаимодействовать. Чем меньше сенсорных точек имеет интерфейс, тем меньше площадь его поверхности и тем проще становится интерфейс. Интерфейс с большой площадью поверхности очень гибкий, но его также может быть намного сложнее понять и использовать, учитывая высокий уровень функциональности, отображаемый интерфейсом.

Этот интерфейс служит двойной цели. Это позволяет нам разрабатывать новые биты и компоненты компонента, только предоставляя функциональные возможности, готовые к общественному потреблению, сохраняя при этом все, что не предназначено для совместного использования с другими компонентами. В то же время он позволяет потребителям, то есть компонентам или системам, использующим наш интерфейс, использовать преимущества функциональности, которые мы раскрываем, не касаясь деталей того, как мы реализовали эту функциональность.

Надежные документированные интерфейсы - один из лучших способов изолировать сложный фрагмент кода, чтобы другие могли использовать его функциональность, не зная каких-либо деталей реализации. Систематическое расположение надежных интерфейсов может быть начислено для формирования слоя, например уровня обслуживания или данных в корпоративных приложениях, и при этом мы могли бы в значительной степени изолировать и описать логику на одном из этих слоев, сохраняя при этом презентацию касается отдельно от проблем, связанных с бизнесом или постоянством. Такое сильное разделение эффективно, потому что оно поддерживает отдельные компоненты аккуратно и равномерно распределяет слои. Равномерные слои, состоящие из компонентов, похожих по образцу или форме, обладают чувством знакомости, что делает их более простыми для использования на постоянной основе с точки зрения одного разработчика, который со временем становится все более привычным для привычных форм API.

Опираясь на согласованные формы API - отличный способ повысить производительность, учитывая сложность разработки адекватных интерфейсов. Когда мы последовательно используем аналогичные формы API, нам не нужно каждый раз придумывать новые проекты, и потребители могут быть уверены, что вы не изобретали колесо каждый раз. Мы подробно обсудим дизайн API в следующих главах.

=== 1.2 Краткая история модульности

Когда дело доходит до JavaScript, модульность - это современная концепция. В этом разделе мы быстро пересматриваем и суммируем основные этапы развития модульности в мире JavaScript. Этот раздел не должен быть исчерпывающим списком любым способом, но вместо этого он предназначен для иллюстрации основных изменений парадигмы по истории JavaScript.

==== 1.2.1 Тэги сценариев и закрытие

В первые дни JavaScript был встроен в теги HTML `<script> '. В лучшем случае он был выгружен в выделенные файлы сценариев, все из которых разделены глобальной областью.

Любые переменные или привязки, объявленные в одном из этих файлов или встроенных сценариях, будут запечатлены на глобальном объекте `window`, создавая утечки по совершенно несвязанным сценариям, которые могли бы привести к конфликтам или даже сломанным событиям, где переменная в одном скрипте могла бы непреднамеренно замените глобальный, на который опирается другой скрипт.

[source,html]
----
<script>
  var initialized = false

  if (!initialized) {
    init()
  }

  function init() {
    initialized = true
    console.log('init')
  }
</script>

<script>
  if (initialized) {
    console.log('was initialized!')
  }

  // even `init` has been implicitly made a global variable
  console.log('init' in window)
</script>
----

В конце концов, по мере того, как веб-приложения начали расти по размеру и сложности, концепция обзора и опасности глобального масштаба стала очевидной и более известной. Выражения мгновенно вызывающих функций (IIFE) были изобретены и стали мгновенным опорой. IIFE работал путем обертывания всего файла или частей файла в функции, которая выполнялась сразу после оценки. Каждая функция в JavaScript создает новый уровень охвата, что означает, что привязки переменной var var будут содержаться в IIFE. Несмотря на то, что объявления переменных поднимаются до вершины их сдерживающей области, они никогда не станут неявными глобалами, благодаря оболочке IIFE, тем самым подавляя хрупкость неявных JavaScript-глобалов.

Несколько вариантов IIFE можно найти в следующем фрагменте примера. Код в каждом IIFE изолирован и может выходить только в глобальный контекст через явные инструкции, такие как `window.fromIIFE = true`.

[source,javascript]
----
(function() {
  console.log('IIFE using parenthesis')
})()

~function() {
  console.log('IIFE using a bitwise operator')
}()

void function() {
  console.log('IIFE using the void operator')
}()
----

Используя шаблон IIFE, библиотеки обычно создают модули, выставляя и повторно применяя единственное связывание на объекте `window`, тем самым сводя к минимуму загрязнение глобального пространства имен. Следующий фрагмент показывает, как мы могли бы создать компонент `mathlib` с методом` sum` в одной из этих библиотек на основе ИФЭ. Если бы мы захотели добавить больше модулей в `mathlib`, мы могли бы разместить каждый из них в отдельном IIFE, который добавит свои собственные методы в открытый интерфейс` mathlib`, в то время как все остальное может оставаться частным для компонента, который определил новую часть функциональность.

[source,javascript]
----
void function() {
  window.mathlib = window.mathlib || {}
  window.mathlib.sum = sum

  function sum(...values) {
    return values.reduce((a, b) => a + b, 0)
  }
}()

mathlib.sum(1, 2, 3)
// <- 6
----

Этот шаблон был, по случайному совпадению, открытым приглашением для инструментария JavaScript для расцвета, позволяя разработчикам - в первый раз - объединить каждый модуль IIFE в один файл, уменьшая нагрузку на сеть. При условии, что примитивные решения для связывания, которые существовали в то время, смогли найти способ автоматического добавления точки с запятой и уменьшенного содержимого без нарушения логики приложения.

Проблема подхода IIFE заключалась в том, что не было явного дерева зависимостей. Это означает, что разработчикам приходилось производить списки файлов компонентов в точном порядке, чтобы нагрузки загружались до того, как все зависящие от них модули - рекурсивно.

==== 1.2.2 RequireJS, AngularJS и инъекция зависимостей

Это проблема, о которой нам едва ли нужно было думать с момента появления модульных систем типа RequireJS или механизма впрыска зависимостей в AngularJS, которые позволили нам явно указывать зависимости каждого модуля.

В следующем примере мы можем определить библиотеку `mathlib / sum.js`, используя функцию` define` RequireJS, которая была добавлена ​​в глобальную область. Возвращаемое значение из обратного вызова `define` затем используется как открытый интерфейс для нашего модуля.

[source,javascript]
----
define(function() {
  return sum

  function sum(...values) {
    return values.reduce((a, b) => a + b, 0)
  }
})
----

Тогда у нас мог бы быть модуль `mathlib.js`, который объединяет все функции, которые мы хотели включить в нашу библиотеку. В нашем случае это просто `mathlib / sum`, но мы могли бы отображать столько же зависимостей, сколько хотели. Мы перечислили каждую зависимость, используя их пути в массиве, и мы получим их публичные интерфейсы как параметры, переданные в наш обратный вызов, в том же порядке.

[source,javascript]
----
define(['mathlib/sum'], function(sum) {
  return { sum }
})
----

Теперь, когда мы определили библиотеку, мы можем ее использовать с помощью `require`. Обратите внимание, как цепочка зависимостей разрешена для нас в приведенном ниже фрагменте.

[source,javascript]
----
require(['mathlib'], function(mathlib) {
  mathlib.sum(1, 2, 3)
  // <- 6
})
----

Это верх в RequireJS и его внутреннем дереве зависимостей. Независимо от того, содержит ли наше приложение сотни или тысячи модулей, RequireJS разрешит дерево зависимостей без необходимости в тщательно сохраненном списке. Учитывая, что мы перечислили зависимости именно там, где они были нужны, мы устранили необходимость в длинном списке каждого компонента и как они связаны друг с другом, а также процесс, связанный с ошибкой в поддержании такого списка. Устранение такого большого источника сложности является лишь побочным эффектом, но не основным преимуществом.

Эта очевидность в декларации зависимости на уровне модуля сделала очевидным, как компонент был связан с другими частями приложения. Эта экспликация, в свою очередь, способствовала большей степени модульности, что раньше было неэффективным из-за того, насколько трудно было следовать цепям зависимостей.

Требование не было без проблем. Весь шаблон вращался вокруг его способности асинхронно загружать модули, которые были плохо информированы о производственных развертываниях из-за того, насколько плохо он выполнялся. Используя механизм асинхронной загрузки, вы выпустили сотни сетевых запросов в режиме водопада, прежде чем большая часть вашего кода была выполнена. Для оптимизации сборки для производства потребуется использовать другой инструмент. Затем был фактор детализации, в котором вы столкнулись с длинными списками зависимостей, вызовом функции RequireJS и обратным вызовом для вашего модуля. В этой заметке было немало различных функций RequireJS и нескольких способов вызова этих функций, что усложняло его использование. API был не самым интуитивным, потому что было так много способов сделать то же самое: объявить модуль с зависимостями.

Система инъекций зависимостей в AngularJS страдает от многих из тех же проблем. Это было изящное решение в то время, полагаясь на умный синтаксический анализ строк, чтобы избежать массива зависимостей, используя имена параметров функций для разрешения зависимостей. Этот механизм был несовместим с minifiers, который переименовал бы параметры в одиночные символы и таким образом сломал бы инжектор.

Позже в течение жизни AngularJS v1 была введена задача построения, которая преобразует код следующим образом:

[source,javascript]
----
module.factory('calculator', function(mathlib) {
  // …
})
----

В формате в следующем бите кода, который был минимально-безопасным, поскольку он включал явный список зависимостей.

[source,javascript]
----
module.factory('calculator', ['mathlib', function(mathlib) {
  // …
}])
----

Излишне говорить, что задержка с введением этого малоизвестного инструмента сборки в сочетании с чрезмерно спроектированным аспектом создания дополнительного шага сборки, чтобы разбить что-то, что не должно было быть сломано, не поощряло использование шаблона, в любом случае, незначительная выгода. Разработчики в основном предпочли придерживаться знакомого формата массивов зависимостей типа RequireJS-типа.

==== 1.2.3 Node.js и Пришествие CommonJS

Среди многих нововведений, одобренных Node.js, одна из них - система модулей CommonJS - или CJS для краткости. Воспользовавшись тем, что программы Node.js имели доступ к файловой системе, стандарт CommonJS в большей степени соответствует традиционным механизмам загрузки модулей. В CommonJS каждый файл представляет собой модуль со своей областью и контекстом. Зависимости загружаются с использованием синхронной функции `require`, которую можно динамически вызывать в любое время в жизненном цикле модуля, как показано в следующем фрагменте.

[source,javascript]
----
const mathlib = require('./mathlib')
----

Подобно требованиям RequireJS и AngularJS, CommonJS также ссылаются на путь. Основное различие заключается в том, что функция шаблона и матрица зависимостей теперь исчезают, а интерфейс из модуля может быть привязан к привязке к переменной или использоваться везде, где может использоваться выражение JavaScript.

В отличие от RequireJS или AngularJS, CommonJS был довольно строгим. В RequireJS и AngularJS у вас может быть много динамически определенных модулей для каждого файла, тогда как CommonJS имеет взаимно однозначное сопоставление между файлами и модулями. В то же время у RequireJS было несколько способов объявления модуля, и у AngularJS было несколько видов заводов, сервисов, поставщиков и т. Д. - кроме того, что его механизм впрыскивания зависимостей был тесно связан с каркасом AngularJS. CommonJS, напротив, имел единственный способ объявления модулей. Любой файл JavaScript был модулем, вызывающий `require` загружал зависимости, а все, что было присвоено` module.exports`, было его интерфейсом. Это позволило улучшить интроспекцию инструментария и кода, что упростило инструменты для изучения иерархии системы компонентов CommonJS.

В конце концов, Browserify был изобретен как способ преодоления разрыва между модулями CommonJS для серверов Node.js и браузером. Используя программу интерфейса командной строки `browserify` и предоставляя ей путь к модулю точки входа, можно объединить немыслимое количество модулей в один пакет, готовый для браузера. Особенностью убийцы CommonJS, реестром пакетов npm, было решающее значение для содействия захвату модуля загрузки экосистемы.

Разумеется, npm не ограничивается модулями CommonJS или даже пакетами JavaScript, но это было и остается по большому счету в его основном использовании. Перспектива иметь тысячи пакетов (в настоящее время более полумиллиона и неуклонно растет), доступных в вашем веб-приложении, нажатием нескольких пальцев, в сочетании с возможностью повторного использования больших частей системы на веб-сервере Node.js и каждый веб-браузер каждого клиента был слишком большим конкурентным преимуществом для других систем, чтобы идти в ногу со временем.

==== 1.2.4 ES6, `import`, Babel и Webpack

Поскольку ES6 стал стандартизован в июне 2015 года, а с Babel, транслирующим ES6 в ES5 задолго до этого, быстро приближалась новая революция. Спецификация ES6 включала в себя синтаксис модуля, свойственный JavaScript, часто называемый модулями ECMAScript (ESM).

ESM в значительной степени зависит от CJS и его предшественников, предлагая статический декларативный API, а также перспективный динамический программируемый API, как показано ниже.

[source,javascript]
----
import mathlib from './mathlib'
import('./mathlib').then(mathlib => {
  // …
})
----

В ESM тоже каждый файл представляет собой модуль с собственной областью и контекстом. Одним из основных преимуществ ESM над CJS является то, как ESM имеет и поощряет - способ статического импорта зависимостей. Статический импорт значительно улучшает возможности самоанализа модульных систем, поскольку они могут быть проанализированы статически и лексически извлечены из абстрактного синтаксического дерева (AST) каждого модуля в системе. Статический импорт в ESM ограничивается самым верхним уровнем модуля, что еще более упрощает синтаксический анализ и интроспекцию. Еще одно преимущество ESM по сравнению с CommonJS `require ()` заключается в том, что ESM указывает способ загрузки асинхронного модуля, что подразумевает, что части графика зависимостей приложения могут быть загружены в ответ на определенные события, одновременно или лениво по мере необходимости. Хотя эта функция еще не реализована в большинстве сред на момент написания этой статьи, есть сильная индикация footnoteref: [esm-node, вы можете погрузиться в специфику этой статьи от члена команды Node.js, Myles Borins: https : //mjavascript.com/out/esm-node.], что Node.js включит его в будущем.

В Node.js v8.5.0 поддержка ESM была введена за флаг `--experimental-modules` - при условии, что мы используем расширение` .mjs` для наших модулей. Большинство вечнозеленых браузеров уже поддерживают ESM без флагов.

Webpack является преемником Browserify, который в значительной степени взял на себя роль универсального модуля-поставщика благодаря более широкому набору функций. Как и в случае с Babel и ES6, Webpack уже давно поддерживает ESM как с его статическими операциями `import`, так и с` export`, а также с динамическим `import ()` function-like expression. Он сделал особенно плодотворное внедрение ESM, в немалой степени благодаря внедрению механизма «расщепления кода»: [Кодовое разделение позволяет разбить ваше приложение на несколько пакетов на основе разных точек входа, а также позволяет вам извлекать зависимости, разделяемые через узлы, в один многоразовый пакет. Подробнее читайте на странице https://mjavascript.com/out/code-splitting.], Благодаря чему он может разбить приложение на разные пакеты для повышения производительности при первом опыте загрузки.

Учитывая, что ESM является родным для языка, - в отличие от CJS - можно ожидать полного преодоления экосистемы модуля через несколько лет.

=== 1.3 Перки модульного дизайна

Мы уже обращали внимание на то, что модульность, в отличие от единой глобальной глобальной области, помогает избежать неожиданных столкновений в именах переменных благодаря диверсификации обзора по всем модулям. Помимо исправления конфликтов, модульность, распространяемая между файлами, ограничивает объем сложности, на которую мы должны обратить внимание при работе над какой-либо одной конкретной функцией. При этом наша команда может сосредоточиться на задаче и быть более продуктивной в результате.

Из-за этого улучшается работоспособность или способность влиять на изменения в кодовой базе. Когда код прост и модулен, его легче использовать и расширять. Поддержание работоспособности ценно независимо от размера команды: даже в команде одного, если мы оставим часть кода незатронутой в течение нескольких месяцев, а затем вернемся к ней, ее может быть сложно улучшить или даже понять, если мы не рассмотрим записывая поддерживаемый код в первый раз.

По умолчанию модульный код должен быть полностью поддерживаемым. Сохраняя фрагменты кода простыми и следуя принципу единой ответственности (SRP), в котором он стремится только выполнить одну цель и объединить эти простые фрагменты кода в более сложные компоненты, мы можем составить наш путь к более крупным компонентам и в конечном счете, целое приложение. Когда каждая часть кода в программе является модульной, кодовая база представляется простой, когда мы смотрим на отдельные компоненты, но в целом она способна проявлять сложное поведение, как и процесс публикации книг, который мы обсуждали в начало этой главы.

Компоненты модульных приложений определяются их интерфейсами. Реализация этих компонентов не является их сущностью, но их интерфейсы. Когда интерфейсы хорошо разработаны, их можно выращивать неразрывными способами, увеличивая количество вариантов использования, которые они могут удовлетворить, без ущерба для существующего использования. Когда у нас есть продуманный интерфейс, реализация за этим интерфейсом становится легкой для настройки или замены. Сильные интерфейсы эффективно скрывают слабые реализации, которые могут быть позже реорганизованы в более надежные реализации при условии, что интерфейс имеет место. Сильные интерфейсы также превосходны для модульного тестирования, потому что нам не придется беспокоиться о реализации, и мы можем протестировать интерфейс - входы и выходы компонента или функции. Если интерфейс хорошо протестирован и прочен, мы можем с уверенностью рассмотреть его реализацию на вторичной плоскости.

Учитывая, что эти реализации являются второстепенными по сравнению с основным требованием наличия интуитивно понятных интерфейсов, которые не связаны с их реализацией, мы можем сосредоточиться на компромиссе между гибкостью и простотой. Гибкость неизбежно возникает за счет дополнительной сложности, что является хорошей причиной для того, чтобы не предлагать гибкие интерфейсы. В то же время гибкость часто является необходимостью, и поэтому нам нужно найти правильный баланс, решив, насколько жестко мы сможем справиться с нашими интерфейсами. Этот баланс будет означать, что интерфейс успокаивает своих потребителей благодаря простоте использования, но при этом он также позволяет использовать расширенные или более необычные случаи использования, если это необходимо, без чрезмерного вредного влияния на простоту использования или за счет значительно расширенной реализации сложность.

Мы обсудим компромисс между гибкостью, простотой, возможностью компоновки и правильным количеством будущей проверки в следующих парах глав.

=== 1.4 Модульная гранулярность

Мы можем применять модульные концепции проектирования на каждом уровне данной системы. Если требования проекта перерастут в первоначальную область, возможно, нам стоит рассмотреть возможность разделения этого проекта на несколько небольших проектов с более малыми командами, которые более управляемы. То же самое можно сказать и о приложениях: когда они становятся большими или сложными, мы можем разделить их на дифференцированные продукты.

Когда мы хотим сделать приложение более пригодным для обслуживания, мы должны рассмотреть возможность создания явно определенных слоев кода, чтобы мы могли расти каждый слой горизонтально, одновременно предотвращая распространение этих дополнений на другие несвязанные слои. Тот же процесс мышления может быть применен к отдельным компонентам, разделяя их на два или более меньших компонента, которые затем связаны еще одним небольшим компонентом, который может действовать как составной слой, единственная ответственность которого заключается в объединении нескольких базовых компонентов.

На уровне модуля мы должны стремиться сохранять функции просто и выразительно, с описательными именами и не слишком много обязанностей. Возможно, у нас будет функция, предназначенная исключительно для сближения группы задач под конкретным асинхронным потоком, имея при этом другие функции для каждой задачи, которые нам нужны для выполнения в этом потоке управления. Самая верхняя функция управления потоком может быть раскрыта как метод открытого интерфейса для нашего модуля, но единственной ее частью, которую следует рассматривать как открытый интерфейс, являются параметры, которые мы получаем в качестве входных данных для этой функции, и выход, созданный той же самой верхней функцией , Все остальное становится деталью реализации и, как таковое, считается заменяемым.

Внутренние функции модуля не будут иметь такой же жесткости интерфейса: до тех пор, пока поддерживается общий интерфейс, мы можем изменить реализацию, включая интерфейсы функций, которые составляют эту реализацию, но мы хотим. Это не означает, однако, что мы должны относиться к этим интерфейсам менее сознательно. Ключ к правильной модульной конструкции заключается в том, что он полностью уважает все интерфейсы и включает интерфейсы, открытые внутренними функциями.

В рамках функций мы также отметим необходимость в детализации аспектов реализации, давая этим аспектам имя в виде вызовов функций, откладывая сложность, которую не нужно немедленно обрабатывать в основной части функции до более поздней в прочтении данного фрагмента кода. Мы пишем программы, предназначенные для чтения и записи для других людей и даже самих себя в будущем. Практически все, кто делал какие-либо программы, испытывали чувство разочарования, когда смотрели на кусок кода, который они сами писали за несколько месяцев до этого, но только позже осознали, что со свежими парами глаз, которые они создали, были не такими твердыми, как они изначально предназначались.

Помните, разработка компьютерных программ в значительной степени связана с человеческими и совместными усилиями. Мы не оптимизируем для компьютеров, чтобы запускать программы как можно быстрее. Если бы мы были, мы бы записывали двоичную или жесткую кодировку в печатные платы. Вместо этого мы сосредоточим внимание на том, чтобы дать возможность организации, чтобы ее разработчики могли оставаться продуктивными и могли быстро понять и даже модифицировать фрагменты кода, с которыми они не сталкивались раньше. Работая под мягким объявлением конвенций и практик, которые создают разработчики на ровном киле, закрывает этот цикл, гарантируя, что будущее развитие согласуется с тем, как приложение сформировалось до настоящего времени.

Возвращаясь к производительности, мы должны рассматривать ее как функцию, где по большей части мы не ставим на нее более высокую премию, чем для других функций. Если производительность не является определяющей функцией нашей системы по причинам бизнеса, мы не должны беспокоиться о том, что система работает на максимальной скорости на всех кодах. Это может привести к очень сложным приложениям, которые трудно поддерживать, отлаживать, расширять и оправдывать.

Мы, как разработчики, часто перестраиваем архитектуру, и здесь также много аргументов в отношении оптимизации производительности. Выстраивание всеобъемлющей архитектуры, которая может свести нас к минимуму, поскольку мы масштабируемся до миллиардов транзакций в секунду, может стоить нам значительного времени, затраченного на авансцену, и, возможно, также блокирует нас в серии абстракций, которые будет сложно не отставать, поскольку в ближайшей перспективе не ожидается никаких ожиданий. Нам гораздо лучше, когда мы фокусируемся на проблемах, с которыми мы уже сталкиваемся, или, может быть, натолкнулись на них, вместо того, чтобы пытаться планировать рост инфраструктуры и пропускной способности хоккейной клюшки без каких-либо данных для поддержки роста хоккейной клюшки, ожидание.

Когда мы не планируем такую ​​долгосрочную форму, возникает интересная вещь: наши системы растут более естественно, адаптируясь к потребностям ближайшего времени, постепенно развиваясь в сторону поддержки более широкого применения и большего набора требований. Когда эта прогрессия постепенна, мы замечаем корректирующее поведение в том, как абстракции собираются или отбрасываются по мере роста. Если мы слишком рано останавливаемся на абстракциях, и они оказываются неправильными абстракциями, мы дорого платим за эту ошибку. Плохие абстракции заставляют нас согнуть все приложения по своей воле, и как только мы осознаем, что абстракция плохая и ее нужно удалить, мы могли бы так сильно инвестировать в нее, что вытащить ее можно было бы дорого. Это связано с падением стоимости потопа, в результате чего у нас возникает соблазн сохранить абстракцию только потому, что мы потратили много времени, пота и крови на нее, может быть очень опасно.

Мы посвятим важную часть этой книги пониманию того, как мы можем определить и использовать правильные абстракции в нужное время, чтобы минимизировать риски, которые они несут.

=== 1.5 Модульный JavaScript: необходимость

Благодаря своей истории JavaScript особенно интересен, когда речь идет о модульном дизайне. В первые дни Интернета и в течение долгого времени не было никаких установленных практик, и мало кто знал язык за пределами отображения предупреждающих ящиков. Как очень динамичный язык, который еще не был достаточно зрелым, JavaScript был в странном месте между статически типизированными языками, такими как Java или C #, и более активно используемыми динамическими языками, такими как Python или PHP.

Отсутствие собственной модульности в сети - из-за того, что программа загружается в куски с использованием тегов HTML `<script>, резко контрастирует с любыми другими средами исполнения, где программы могут состоять из любого количества файлов и модульные архитектуры поддерживаются языком, его компилятором и средой, основанной на файловой системе. В Интернете мы только сейчас начинаем царапать поверхность собственных модулей, с другой стороны, с другой стороны, с другой стороны. Как мы обсуждали в разделе 1.2, отсутствие механизма загрузки собственного модуля в сочетании с отсутствием встроенных модулей помимо обычных файлов, разделяющих глобальную область, заставляло веб-сообщество проявлять творческий подход к модульности.

Спецификация встроенных JavaScript-модулей, которые в конечном итоге приземлились на язык, сильно зависела от этих усилий, проводимых под руководством сообщества. Даже на момент написания этой статьи мы все еще, вероятно, находимся на расстоянии 2 или 3 лет от возможности эффективно использовать собственную модульную систему в Интернете. Этот недостаток Интернета подтверждается тем, что шаблоны, которые были приняты повсеместно в других местах, например многоуровневые или компонентные архитектуры, даже не рассматривались в Интернете на протяжении большей части его жизни.

До запуска бета-клиента Gmail в апреле 2004 года, который продемонстрировал мощь асинхронных HTTP-запросов JavaScript для обеспечения одностраничного применения приложений, а затем начального выпуска jQuery в 2006 году, который обеспечивал беспроблемную кросс- опыт веб-разработки браузера, JavaScript редко рассматривался как серьезная платформа для современного развития.

С появлением каркасов, таких как Backbone, Angular, Ember и React, новые технологии и прорывы также сделали всплеск в Интернете. Написание кода под ES6 и далее, но затем перекодирование частей этого кода на ES5 для обеспечения более широкой поддержки браузера; совместный рендеринг с использованием того же кода на сервере и клиенте для быстрого отображения страницы при начальной загрузке страницы и быстрой загрузки страниц при навигации; автоматическое связывание кода, упаковка модулей, составляющих приложение, в один комплект для оптимизации доставки; расщепление пучков вдоль маршрутов, так что есть несколько выпущенных пакетов, каждый из которых оптимизирован для первоначально посещенного маршрута; Компоновка CSS на уровне модуля JavaScript, так что CSS, который не содержит синтаксис собственного модуля, также может быть разделен на пучки; и множество способов оптимизации таких активов, как изображения во время компиляции, повышения производительности во время разработки при сохранении высокопроизводительных производственных процессов, являются частью итеративного характера инноваций в Интернете.

Этот взрыв инноваций связан не только с одним творческим творчеством, но и по необходимости: веб-приложения становятся все более сложными, а также их объем, цель и требования. Следовательно, логично, что экосистема вокруг них будет расти для удовлетворения этих расширенных требований с точки зрения лучшей оснастки, улучшения библиотек, лучшей практики кодирования, архитектур, стандартов, шаблонов и большего выбора в целом.

В следующей главе мы сломаем значение сложности и начнем строить укрепления против сложности в программах, которые мы пишем. Следуя нескольким правилам о том, как мы инкапсулируем логику через слои на слоях компонентов, мы начнем наше путешествие к более простому дизайну программы.
